{"version":3,"file":"./build/dom/index.min.js","mappings":"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","sources":["webpack://wp/webpack/bootstrap","webpack://wp/webpack/runtime/define property getters","webpack://wp/webpack/runtime/hasOwnProperty shorthand","webpack://wp/webpack/runtime/make namespace object","webpack://wp/./packages/dom/build-module/@wordpress/dom/src/focusable.js","webpack://wp/external window \"lodash\"","webpack://wp/./packages/dom/build-module/@wordpress/dom/src/tabbable.js","webpack://wp/./packages/dom/build-module/dom/@wordpress/dom/src/dom/get-rectangle-from-range.js","webpack://wp/./packages/dom/build-module/dom/@wordpress/dom/src/dom/compute-caret-rect.js","webpack://wp/./packages/dom/build-module/dom/@wordpress/dom/src/dom/document-has-text-selection.js","webpack://wp/./packages/dom/build-module/dom/@wordpress/dom/src/dom/is-html-input-element.js","webpack://wp/./packages/dom/build-module/dom/@wordpress/dom/src/dom/is-text-field.js","webpack://wp/./packages/dom/build-module/dom/@wordpress/dom/src/dom/is-number-input.js","webpack://wp/./packages/dom/build-module/dom/@wordpress/dom/src/dom/document-has-uncollapsed-selection.js","webpack://wp/./packages/dom/build-module/dom/@wordpress/dom/src/dom/input-field-has-uncollapsed-selection.js","webpack://wp/./packages/dom/build-module/dom/@wordpress/dom/src/dom/document-has-selection.js","webpack://wp/./packages/dom/build-module/dom/@wordpress/dom/src/dom/get-computed-style.js","webpack://wp/./packages/dom/build-module/dom/@wordpress/dom/src/dom/get-scroll-container.js","webpack://wp/./packages/dom/build-module/dom/@wordpress/dom/src/dom/get-offset-parent.js","webpack://wp/./packages/dom/build-module/dom/@wordpress/dom/src/dom/is-input-or-text-area.js","webpack://wp/./packages/dom/build-module/dom/@wordpress/dom/src/dom/is-entirely-selected.js","webpack://wp/./packages/dom/build-module/dom/@wordpress/dom/src/dom/is-rtl.js","webpack://wp/./packages/dom/build-module/dom/@wordpress/dom/src/dom/get-range-height.js","webpack://wp/./packages/dom/build-module/dom/@wordpress/dom/src/dom/is-selection-forward.js","webpack://wp/./packages/dom/build-module/dom/@wordpress/dom/src/dom/hidden-caret-range-from-point.js","webpack://wp/./packages/dom/build-module/dom/@wordpress/dom/src/dom/caret-range-from-point.js","webpack://wp/./packages/dom/build-module/dom/@wordpress/dom/src/dom/is-edge.js","webpack://wp/./packages/dom/build-module/dom/@wordpress/dom/src/dom/is-horizontal-edge.js","webpack://wp/./packages/dom/build-module/dom/@wordpress/dom/src/dom/is-vertical-edge.js","webpack://wp/./packages/dom/build-module/dom/@wordpress/dom/src/dom/place-caret-at-edge.js","webpack://wp/./packages/dom/build-module/dom/@wordpress/dom/src/dom/place-caret-at-horizontal-edge.js","webpack://wp/./packages/dom/build-module/dom/@wordpress/dom/src/dom/place-caret-at-vertical-edge.js","webpack://wp/./packages/dom/build-module/dom/@wordpress/dom/src/dom/insert-after.js","webpack://wp/./packages/dom/build-module/dom/@wordpress/dom/src/dom/remove.js","webpack://wp/./packages/dom/build-module/dom/@wordpress/dom/src/dom/replace.js","webpack://wp/./packages/dom/build-module/dom/@wordpress/dom/src/dom/unwrap.js","webpack://wp/./packages/dom/build-module/dom/@wordpress/dom/src/dom/replace-tag.js","webpack://wp/./packages/dom/build-module/dom/@wordpress/dom/src/dom/wrap.js","webpack://wp/./packages/dom/build-module/dom/@wordpress/dom/src/dom/safe-html.js","webpack://wp/./packages/dom/build-module/dom/@wordpress/dom/src/dom/strip-html.js","webpack://wp/./packages/dom/build-module/dom/@wordpress/dom/src/dom/is-empty.js","webpack://wp/./packages/dom/build-module/@wordpress/dom/src/phrasing-content.js","webpack://wp/./packages/dom/build-module/dom/@wordpress/dom/src/dom/clean-node-list.js","webpack://wp/./packages/dom/build-module/dom/@wordpress/dom/src/dom/is-element.js","webpack://wp/./packages/dom/build-module/dom/@wordpress/dom/src/dom/remove-invalid-html.js","webpack://wp/./packages/dom/build-module/@wordpress/dom/src/data-transfer.js","webpack://wp/./packages/dom/build-module/@wordpress/dom/src/index.js"],"sourcesContent":["// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = function(exports, definition) {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }","// define __esModule on exports\n__webpack_require__.r = function(exports) {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","/**\n * References:\n *\n * Focusable:\n *  - https://www.w3.org/TR/html5/editing.html#focus-management\n *\n * Sequential focus navigation:\n *  - https://www.w3.org/TR/html5/editing.html#sequential-focus-navigation-and-the-tabindex-attribute\n *\n * Disabled elements:\n *  - https://www.w3.org/TR/html5/disabled-elements.html#disabled-elements\n *\n * getClientRects algorithm (requiring layout box):\n *  - https://www.w3.org/TR/cssom-view-1/#extension-to-the-element-interface\n *\n * AREA elements associated with an IMG:\n *  - https://w3c.github.io/html/editing.html#data-model\n */\n\n/**\n * Returns a CSS selector used to query for focusable elements.\n *\n * @param {boolean} sequential If set, only query elements that are sequentially\n *                             focusable. Non-interactive elements with a\n *                             negative `tabindex` are focusable but not\n *                             sequentially focusable.\n *                             https://html.spec.whatwg.org/multipage/interaction.html#the-tabindex-attribute\n *\n * @return {string} CSS selector.\n */\nfunction buildSelector( sequential ) {\n\treturn [\n\t\tsequential ? '[tabindex]:not([tabindex^=\"-\"])' : '[tabindex]',\n\t\t'a[href]',\n\t\t'button:not([disabled])',\n\t\t'input:not([type=\"hidden\"]):not([disabled])',\n\t\t'select:not([disabled])',\n\t\t'textarea:not([disabled])',\n\t\t'iframe:not([tabindex^=\"-\"])',\n\t\t'object',\n\t\t'embed',\n\t\t'area[href]',\n\t\t'[contenteditable]:not([contenteditable=false])',\n\t].join( ',' );\n}\n\n/**\n * Returns true if the specified element is visible (i.e. neither display: none\n * nor visibility: hidden).\n *\n * @param {HTMLElement} element DOM element to test.\n *\n * @return {boolean} Whether element is visible.\n */\nfunction isVisible( element ) {\n\treturn (\n\t\telement.offsetWidth > 0 ||\n\t\telement.offsetHeight > 0 ||\n\t\telement.getClientRects().length > 0\n\t);\n}\n\n/**\n * Returns true if the specified area element is a valid focusable element, or\n * false otherwise. Area is only focusable if within a map where a named map\n * referenced by an image somewhere in the document.\n *\n * @param {HTMLAreaElement} element DOM area element to test.\n *\n * @return {boolean} Whether area element is valid for focus.\n */\nfunction isValidFocusableArea( element ) {\n\t/** @type {HTMLMapElement | null} */\n\tconst map = element.closest( 'map[name]' );\n\tif ( ! map ) {\n\t\treturn false;\n\t}\n\n\t/** @type {HTMLImageElement | null} */\n\tconst img = element.ownerDocument.querySelector(\n\t\t'img[usemap=\"#' + map.name + '\"]'\n\t);\n\treturn !! img && isVisible( img );\n}\n\n/**\n * Returns all focusable elements within a given context.\n *\n * @param {Element} context              Element in which to search.\n * @param {Object}  [options]\n * @param {boolean} [options.sequential] If set, only return elements that are\n *                                       sequentially focusable.\n *                                       Non-interactive elements with a\n *                                       negative `tabindex` are focusable but\n *                                       not sequentially focusable.\n *                                       https://html.spec.whatwg.org/multipage/interaction.html#the-tabindex-attribute\n *\n * @return {Element[]} Focusable elements.\n */\nexport function find( context, { sequential = false } = {} ) {\n\t/* eslint-disable jsdoc/no-undefined-types */\n\t/** @type {NodeListOf<HTMLElement>} */\n\t/* eslint-enable jsdoc/no-undefined-types */\n\tconst elements = context.querySelectorAll( buildSelector( sequential ) );\n\n\treturn Array.from( elements ).filter( ( element ) => {\n\t\tif ( ! isVisible( element ) ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst { nodeName } = element;\n\t\tif ( 'AREA' === nodeName ) {\n\t\t\treturn isValidFocusableArea(\n\t\t\t\t/** @type {HTMLAreaElement} */ ( element )\n\t\t\t);\n\t\t}\n\n\t\treturn true;\n\t} );\n}\n","var __WEBPACK_NAMESPACE_OBJECT__ = window[\"lodash\"];","/**\n * External dependencies\n */\nimport { without, first, last } from 'lodash';\n\n/**\n * Internal dependencies\n */\nimport { find as findFocusable } from './focusable';\n\n/**\n * Returns the tab index of the given element. In contrast with the tabIndex\n * property, this normalizes the default (0) to avoid browser inconsistencies,\n * operating under the assumption that this function is only ever called with a\n * focusable node.\n *\n * @see https://bugzilla.mozilla.org/show_bug.cgi?id=1190261\n *\n * @param {Element} element Element from which to retrieve.\n *\n * @return {number} Tab index of element (default 0).\n */\nfunction getTabIndex( element ) {\n\tconst tabIndex = element.getAttribute( 'tabindex' );\n\treturn tabIndex === null ? 0 : parseInt( tabIndex, 10 );\n}\n\n/**\n * Returns true if the specified element is tabbable, or false otherwise.\n *\n * @param {Element} element Element to test.\n *\n * @return {boolean} Whether element is tabbable.\n */\nexport function isTabbableIndex( element ) {\n\treturn getTabIndex( element ) !== -1;\n}\n\n/** @typedef {Element & { type?: string, checked?: boolean, name?: string }} MaybeHTMLInputElement */\n\n/**\n * Returns a stateful reducer function which constructs a filtered array of\n * tabbable elements, where at most one radio input is selected for a given\n * name, giving priority to checked input, falling back to the first\n * encountered.\n *\n * @return {(acc: MaybeHTMLInputElement[], el: MaybeHTMLInputElement) => MaybeHTMLInputElement[]} Radio group collapse reducer.\n */\nfunction createStatefulCollapseRadioGroup() {\n\t/** @type {Record<string, MaybeHTMLInputElement>} */\n\tconst CHOSEN_RADIO_BY_NAME = {};\n\n\treturn function collapseRadioGroup(\n\t\t/** @type {MaybeHTMLInputElement[]} */ result,\n\t\t/** @type {MaybeHTMLInputElement} */ element\n\t) {\n\t\tconst { nodeName, type, checked, name } = element;\n\n\t\t// For all non-radio tabbables, construct to array by concatenating.\n\t\tif ( nodeName !== 'INPUT' || type !== 'radio' || ! name ) {\n\t\t\treturn result.concat( element );\n\t\t}\n\n\t\tconst hasChosen = CHOSEN_RADIO_BY_NAME.hasOwnProperty( name );\n\n\t\t// Omit by skipping concatenation if the radio element is not chosen.\n\t\tconst isChosen = checked || ! hasChosen;\n\t\tif ( ! isChosen ) {\n\t\t\treturn result;\n\t\t}\n\n\t\t// At this point, if there had been a chosen element, the current\n\t\t// element is checked and should take priority. Retroactively remove\n\t\t// the element which had previously been considered the chosen one.\n\t\tif ( hasChosen ) {\n\t\t\tconst hadChosenElement = CHOSEN_RADIO_BY_NAME[ name ];\n\t\t\tresult = without( result, hadChosenElement );\n\t\t}\n\n\t\tCHOSEN_RADIO_BY_NAME[ name ] = element;\n\n\t\treturn result.concat( element );\n\t};\n}\n\n/**\n * An array map callback, returning an object with the element value and its\n * array index location as properties. This is used to emulate a proper stable\n * sort where equal tabIndex should be left in order of their occurrence in the\n * document.\n *\n * @param {Element} element Element.\n * @param {number}  index   Array index of element.\n *\n * @return {{ element: Element, index: number }} Mapped object with element, index.\n */\nfunction mapElementToObjectTabbable( element, index ) {\n\treturn { element, index };\n}\n\n/**\n * An array map callback, returning an element of the given mapped object's\n * element value.\n *\n * @param {{ element: Element }} object Mapped object with element.\n *\n * @return {Element} Mapped object element.\n */\nfunction mapObjectTabbableToElement( object ) {\n\treturn object.element;\n}\n\n/**\n * A sort comparator function used in comparing two objects of mapped elements.\n *\n * @see mapElementToObjectTabbable\n *\n * @param {{ element: Element, index: number }} a First object to compare.\n * @param {{ element: Element, index: number }} b Second object to compare.\n *\n * @return {number} Comparator result.\n */\nfunction compareObjectTabbables( a, b ) {\n\tconst aTabIndex = getTabIndex( a.element );\n\tconst bTabIndex = getTabIndex( b.element );\n\n\tif ( aTabIndex === bTabIndex ) {\n\t\treturn a.index - b.index;\n\t}\n\n\treturn aTabIndex - bTabIndex;\n}\n\n/**\n * Givin focusable elements, filters out tabbable element.\n *\n * @param {Element[]} focusables Focusable elements to filter.\n *\n * @return {Element[]} Tabbable elements.\n */\nfunction filterTabbable( focusables ) {\n\treturn focusables\n\t\t.filter( isTabbableIndex )\n\t\t.map( mapElementToObjectTabbable )\n\t\t.sort( compareObjectTabbables )\n\t\t.map( mapObjectTabbableToElement )\n\t\t.reduce( createStatefulCollapseRadioGroup(), [] );\n}\n\n/**\n * @param {Element} context\n * @return {Element[]} Tabbable elements within the context.\n */\nexport function find( context ) {\n\treturn filterTabbable( findFocusable( context ) );\n}\n\n/**\n * Given a focusable element, find the preceding tabbable element.\n *\n * @param {Element} element The focusable element before which to look. Defaults\n *                          to the active element.\n *\n * @return {Element|undefined} Preceding tabbable element.\n */\nexport function findPrevious( element ) {\n\tconst focusables = findFocusable( element.ownerDocument.body );\n\tconst index = focusables.indexOf( element );\n\n\tif ( index === -1 ) {\n\t\treturn undefined;\n\t}\n\n\t// Remove all focusables after and including `element`.\n\tfocusables.length = index;\n\n\treturn last( filterTabbable( focusables ) );\n}\n\n/**\n * Given a focusable element, find the next tabbable element.\n *\n * @param {Element} element The focusable element after which to look. Defaults\n *                          to the active element.\n */\nexport function findNext( element ) {\n\tconst focusables = findFocusable( element.ownerDocument.body );\n\tconst index = focusables.indexOf( element );\n\n\t// Remove all focusables before and including `element`.\n\tconst remaining = focusables.slice( index + 1 );\n\n\treturn first( filterTabbable( remaining ) );\n}\n","/**\n * Internal dependencies\n */\nimport { assertIsDefined } from '../utils/assert-is-defined';\n\n/**\n * Get the rectangle of a given Range.\n *\n * @param {Range} range The range.\n *\n * @return {DOMRect} The rectangle.\n */\nexport default function getRectangleFromRange( range ) {\n\t// For uncollapsed ranges, get the rectangle that bounds the contents of the\n\t// range; this a rectangle enclosing the union of the bounding rectangles\n\t// for all the elements in the range.\n\tif ( ! range.collapsed ) {\n\t\tconst rects = Array.from( range.getClientRects() );\n\n\t\t// If there's just a single rect, return it.\n\t\tif ( rects.length === 1 ) {\n\t\t\treturn rects[ 0 ];\n\t\t}\n\n\t\t// Ignore tiny selection at the edge of a range.\n\t\tconst filteredRects = rects.filter( ( { width } ) => width > 1 );\n\n\t\t// If it's full of tiny selections, return browser default.\n\t\tif ( filteredRects.length === 0 ) {\n\t\t\treturn range.getBoundingClientRect();\n\t\t}\n\n\t\tif ( filteredRects.length === 1 ) {\n\t\t\treturn filteredRects[ 0 ];\n\t\t}\n\n\t\tlet {\n\t\t\ttop: furthestTop,\n\t\t\tbottom: furthestBottom,\n\t\t\tleft: furthestLeft,\n\t\t\tright: furthestRight,\n\t\t} = filteredRects[ 0 ];\n\n\t\tfor ( const { top, bottom, left, right } of filteredRects ) {\n\t\t\tif ( top < furthestTop ) furthestTop = top;\n\t\t\tif ( bottom > furthestBottom ) furthestBottom = bottom;\n\t\t\tif ( left < furthestLeft ) furthestLeft = left;\n\t\t\tif ( right > furthestRight ) furthestRight = right;\n\t\t}\n\n\t\treturn new window.DOMRect(\n\t\t\tfurthestLeft,\n\t\t\tfurthestTop,\n\t\t\tfurthestRight - furthestLeft,\n\t\t\tfurthestBottom - furthestTop\n\t\t);\n\t}\n\n\tconst { startContainer } = range;\n\tconst { ownerDocument } = startContainer;\n\n\t// Correct invalid \"BR\" ranges. The cannot contain any children.\n\tif ( startContainer.nodeName === 'BR' ) {\n\t\tconst { parentNode } = startContainer;\n\t\tassertIsDefined( parentNode, 'parentNode' );\n\t\tconst index = /** @type {Node[]} */ ( Array.from(\n\t\t\tparentNode.childNodes\n\t\t) ).indexOf( startContainer );\n\n\t\tassertIsDefined( ownerDocument, 'ownerDocument' );\n\t\trange = ownerDocument.createRange();\n\t\trange.setStart( parentNode, index );\n\t\trange.setEnd( parentNode, index );\n\t}\n\n\tlet rect = range.getClientRects()[ 0 ];\n\n\t// If the collapsed range starts (and therefore ends) at an element node,\n\t// `getClientRects` can be empty in some browsers. This can be resolved\n\t// by adding a temporary text node with zero-width space to the range.\n\t//\n\t// See: https://stackoverflow.com/a/6847328/995445\n\tif ( ! rect ) {\n\t\tassertIsDefined( ownerDocument, 'ownerDocument' );\n\t\tconst padNode = ownerDocument.createTextNode( '\\u200b' );\n\t\t// Do not modify the live range.\n\t\trange = range.cloneRange();\n\t\trange.insertNode( padNode );\n\t\trect = range.getClientRects()[ 0 ];\n\t\tassertIsDefined( padNode.parentNode, 'padNode.parentNode' );\n\t\tpadNode.parentNode.removeChild( padNode );\n\t}\n\n\treturn rect;\n}\n","/**\n * Internal dependencies\n */\nimport getRectangleFromRange from './get-rectangle-from-range';\nimport { assertIsDefined } from '../utils/assert-is-defined';\n\n/**\n * Get the rectangle for the selection in a container.\n *\n * @param {Window} win The window of the selection.\n *\n * @return {DOMRect | null} The rectangle.\n */\nexport default function computeCaretRect( win ) {\n\tconst selection = win.getSelection();\n\tassertIsDefined( selection, 'selection' );\n\tconst range = selection.rangeCount ? selection.getRangeAt( 0 ) : null;\n\n\tif ( ! range ) {\n\t\treturn null;\n\t}\n\n\treturn getRectangleFromRange( range );\n}\n","/**\n * Internal dependencies\n */\nimport { assertIsDefined } from '../utils/assert-is-defined';\n\n/**\n * Check whether the current document has selected text. This applies to ranges\n * of text in the document, and not selection inside `<input>` and `<textarea>`\n * elements.\n *\n * See: https://developer.mozilla.org/en-US/docs/Web/API/Window/getSelection#Related_objects.\n *\n * @param {Document} doc The document to check.\n *\n * @return {boolean} True if there is selection, false if not.\n */\nexport default function documentHasTextSelection( doc ) {\n\tassertIsDefined( doc.defaultView, 'doc.defaultView' );\n\tconst selection = doc.defaultView.getSelection();\n\tassertIsDefined( selection, 'selection' );\n\tconst range = selection.rangeCount ? selection.getRangeAt( 0 ) : null;\n\treturn !! range && ! range.collapsed;\n}\n","/* eslint-disable jsdoc/valid-types */\n/**\n * @param {Node} node\n * @return {node is HTMLInputElement} Whether the node is an HTMLInputElement.\n */\nexport default function isHTMLInputElement( node ) {\n\t/* eslint-enable jsdoc/valid-types */\n\treturn !! node && node.nodeName === 'INPUT';\n}\n","/**\n * Internal dependencies\n */\nimport isHTMLInputElement from './is-html-input-element';\n\n/* eslint-disable jsdoc/valid-types */\n/**\n * Check whether the given element is a text field, where text field is defined\n * by the ability to select within the input, or that it is contenteditable.\n *\n * See: https://html.spec.whatwg.org/#textFieldSelection\n *\n * @param {Node} node The HTML element.\n * @return {node is HTMLElement} True if the element is an text field, false if not.\n */\nexport default function isTextField( node ) {\n\t/* eslint-enable jsdoc/valid-types */\n\tconst nonTextInputs = [\n\t\t'button',\n\t\t'checkbox',\n\t\t'hidden',\n\t\t'file',\n\t\t'radio',\n\t\t'image',\n\t\t'range',\n\t\t'reset',\n\t\t'submit',\n\t\t'number',\n\t];\n\treturn (\n\t\t( isHTMLInputElement( node ) &&\n\t\t\tnode.type &&\n\t\t\t! nonTextInputs.includes( node.type ) ) ||\n\t\tnode.nodeName === 'TEXTAREA' ||\n\t\t/** @type {HTMLElement} */ ( node ).contentEditable === 'true'\n\t);\n}\n","/**\n * Internal dependencies\n */\nimport isHTMLInputElement from './is-html-input-element';\n\n/* eslint-disable jsdoc/valid-types */\n/**\n * Check whether the given element is an input field of type number\n * and has a valueAsNumber\n *\n * @param {Node} node The HTML node.\n *\n * @return {node is HTMLInputElement} True if the node is input and holds a number.\n */\nexport default function isNumberInput( node ) {\n\t/* eslint-enable jsdoc/valid-types */\n\treturn (\n\t\tisHTMLInputElement( node ) &&\n\t\tnode.type === 'number' &&\n\t\t!! node.valueAsNumber\n\t);\n}\n","/**\n * Internal dependencies\n */\nimport documentHasTextSelection from './document-has-text-selection';\nimport inputFieldHasUncollapsedSelection from './input-field-has-uncollapsed-selection';\n\n/**\n * Check whether the current document has any sort of selection. This includes\n * ranges of text across elements and any selection inside `<input>` and\n * `<textarea>` elements.\n *\n * @param {Document} doc The document to check.\n *\n * @return {boolean} Whether there is any sort of \"selection\" in the document.\n */\nexport default function documentHasUncollapsedSelection( doc ) {\n\treturn (\n\t\tdocumentHasTextSelection( doc ) ||\n\t\t( !! doc.activeElement &&\n\t\t\tinputFieldHasUncollapsedSelection( doc.activeElement ) )\n\t);\n}\n","/**\n * Internal dependencies\n */\nimport isTextField from './is-text-field';\nimport isNumberInput from './is-number-input';\n\n/**\n * Check whether the given element, assumed an input field or textarea,\n * contains a (uncollapsed) selection of text.\n *\n * Note: this is perhaps an abuse of the term \"selection\", since these elements\n * manage selection differently and aren't covered by Selection#collapsed.\n *\n * See: https://developer.mozilla.org/en-US/docs/Web/API/Window/getSelection#Related_objects.\n *\n * @param {Element} element The HTML element.\n *\n * @return {boolean} Whether the input/textareaa element has some \"selection\".\n */\nexport default function inputFieldHasUncollapsedSelection( element ) {\n\tif ( ! isTextField( element ) && ! isNumberInput( element ) ) {\n\t\treturn false;\n\t}\n\ttry {\n\t\tconst {\n\t\t\tselectionStart,\n\t\t\tselectionEnd,\n\t\t} = /** @type {HTMLInputElement | HTMLTextAreaElement} */ ( element );\n\n\t\treturn selectionStart !== null && selectionStart !== selectionEnd;\n\t} catch ( error ) {\n\t\t// Safari throws an exception when trying to get `selectionStart`\n\t\t// on non-text <input> elements (which, understandably, don't\n\t\t// have the text selection API). We catch this via a try/catch\n\t\t// block, as opposed to a more explicit check of the element's\n\t\t// input types, because of Safari's non-standard behavior. This\n\t\t// also means we don't have to worry about the list of input\n\t\t// types that support `selectionStart` changing as the HTML spec\n\t\t// evolves over time.\n\t\treturn false;\n\t}\n}\n","/**\n * Internal dependencies\n */\nimport isTextField from './is-text-field';\nimport isNumberInput from './is-number-input';\nimport documentHasTextSelection from './document-has-text-selection';\n\n/**\n * Check whether the current document has a selection. This checks for both\n * focus in an input field and general text selection.\n *\n * @param {Document} doc The document to check.\n *\n * @return {boolean} True if there is selection, false if not.\n */\nexport default function documentHasSelection( doc ) {\n\treturn (\n\t\t!! doc.activeElement &&\n\t\t( isTextField( doc.activeElement ) ||\n\t\t\tisNumberInput( doc.activeElement ) ||\n\t\t\tdocumentHasTextSelection( doc ) )\n\t);\n}\n","/**\n * Internal dependencies\n */\nimport { assertIsDefined } from '../utils/assert-is-defined';\n\n/* eslint-disable jsdoc/valid-types */\n/**\n * @param {Element} element\n * @return {ReturnType<Window['getComputedStyle']>} The computed style for the element.\n */\nexport default function getComputedStyle( element ) {\n\t/* eslint-enable jsdoc/valid-types */\n\tassertIsDefined(\n\t\telement.ownerDocument.defaultView,\n\t\t'element.ownerDocument.defaultView'\n\t);\n\treturn element.ownerDocument.defaultView.getComputedStyle( element );\n}\n","/**\n * Internal dependencies\n */\nimport getComputedStyle from './get-computed-style';\n\n/**\n * Given a DOM node, finds the closest scrollable container node.\n *\n * @param {Element | null} node Node from which to start.\n *\n * @return {Element | undefined} Scrollable container node, if found.\n */\nexport default function getScrollContainer( node ) {\n\tif ( ! node ) {\n\t\treturn undefined;\n\t}\n\n\t// Scrollable if scrollable height exceeds displayed...\n\tif ( node.scrollHeight > node.clientHeight ) {\n\t\t// ...except when overflow is defined to be hidden or visible\n\t\tconst { overflowY } = getComputedStyle( node );\n\t\tif ( /(auto|scroll)/.test( overflowY ) ) {\n\t\t\treturn node;\n\t\t}\n\t}\n\n\t// Continue traversing.\n\treturn getScrollContainer( /** @type {Element} */ ( node.parentNode ) );\n}\n","/**\n * Internal dependencies\n */\nimport getComputedStyle from './get-computed-style';\n\n/**\n * Returns the closest positioned element, or null under any of the conditions\n * of the offsetParent specification. Unlike offsetParent, this function is not\n * limited to HTMLElement and accepts any Node (e.g. Node.TEXT_NODE).\n *\n * @see https://drafts.csswg.org/cssom-view/#dom-htmlelement-offsetparent\n *\n * @param {Node} node Node from which to find offset parent.\n *\n * @return {Node | null} Offset parent.\n */\nexport default function getOffsetParent( node ) {\n\t// Cannot retrieve computed style or offset parent only anything other than\n\t// an element node, so find the closest element node.\n\tlet closestElement;\n\twhile ( ( closestElement = /** @type {Node} */ ( node.parentNode ) ) ) {\n\t\tif ( closestElement.nodeType === closestElement.ELEMENT_NODE ) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif ( ! closestElement ) {\n\t\treturn null;\n\t}\n\n\t// If the closest element is already positioned, return it, as offsetParent\n\t// does not otherwise consider the node itself.\n\tif (\n\t\tgetComputedStyle( /** @type {Element} */ ( closestElement ) )\n\t\t\t.position !== 'static'\n\t) {\n\t\treturn closestElement;\n\t}\n\n\t// offsetParent is undocumented/draft.\n\treturn /** @type {Node & { offsetParent: Node }} */ ( closestElement )\n\t\t.offsetParent;\n}\n","/* eslint-disable jsdoc/valid-types */\n/**\n * @param {Element} element\n * @return {element is HTMLInputElement | HTMLTextAreaElement} Whether the element is an input or textarea\n */\nexport default function isInputOrTextArea( element ) {\n\t/* eslint-enable jsdoc/valid-types */\n\treturn element.tagName === 'INPUT' || element.tagName === 'TEXTAREA';\n}\n","/**\n * Internal dependencies\n */\nimport { assertIsDefined } from '../utils/assert-is-defined';\nimport isInputOrTextArea from './is-input-or-text-area';\n\n/**\n * Check whether the contents of the element have been entirely selected.\n * Returns true if there is no possibility of selection.\n *\n * @param {HTMLElement} element The element to check.\n *\n * @return {boolean} True if entirely selected, false if not.\n */\nexport default function isEntirelySelected( element ) {\n\tif ( isInputOrTextArea( element ) ) {\n\t\treturn (\n\t\t\telement.selectionStart === 0 &&\n\t\t\telement.value.length === element.selectionEnd\n\t\t);\n\t}\n\n\tif ( ! element.isContentEditable ) {\n\t\treturn true;\n\t}\n\n\tconst { ownerDocument } = element;\n\tconst { defaultView } = ownerDocument;\n\tassertIsDefined( defaultView, 'defaultView' );\n\tconst selection = defaultView.getSelection();\n\tassertIsDefined( selection, 'selection' );\n\tconst range = selection.rangeCount ? selection.getRangeAt( 0 ) : null;\n\n\tif ( ! range ) {\n\t\treturn true;\n\t}\n\n\tconst { startContainer, endContainer, startOffset, endOffset } = range;\n\n\tif (\n\t\tstartContainer === element &&\n\t\tendContainer === element &&\n\t\tstartOffset === 0 &&\n\t\tendOffset === element.childNodes.length\n\t) {\n\t\treturn true;\n\t}\n\n\tconst lastChild = element.lastChild;\n\tassertIsDefined( lastChild, 'lastChild' );\n\tconst endContainerContentLength =\n\t\tendContainer.nodeType === endContainer.TEXT_NODE\n\t\t\t? /** @type {Text} */ ( endContainer ).data.length\n\t\t\t: endContainer.childNodes.length;\n\n\treturn (\n\t\tisDeepChild( startContainer, element, 'firstChild' ) &&\n\t\tisDeepChild( endContainer, element, 'lastChild' ) &&\n\t\tstartOffset === 0 &&\n\t\tendOffset === endContainerContentLength\n\t);\n}\n\n/**\n * Check whether the contents of the element have been entirely selected.\n * Returns true if there is no possibility of selection.\n *\n * @param {HTMLElement|Node}         query     The element to check.\n * @param {HTMLElement}              container The container that we suspect \"query\" may be a first or last child of.\n * @param {\"firstChild\"|\"lastChild\"} propName  \"firstChild\" or \"lastChild\"\n *\n * @return {boolean} True if query is a deep first/last child of container, false otherwise.\n */\nfunction isDeepChild( query, container, propName ) {\n\t/** @type {HTMLElement | ChildNode | null} */\n\tlet candidate = container;\n\tdo {\n\t\tif ( query === candidate ) {\n\t\t\treturn true;\n\t\t}\n\t\tcandidate = candidate[ propName ];\n\t} while ( candidate );\n\treturn false;\n}\n","/**\n * Internal dependencies\n */\nimport getComputedStyle from './get-computed-style';\n\n/**\n * Whether the element's text direction is right-to-left.\n *\n * @param {Element} element The element to check.\n *\n * @return {boolean} True if rtl, false if ltr.\n */\nexport default function isRTL( element ) {\n\treturn getComputedStyle( element ).direction === 'rtl';\n}\n","/**\n * Gets the height of the range without ignoring zero width rectangles, which\n * some browsers ignore when creating a union.\n *\n * @param {Range} range The range to check.\n * @return {number | undefined} Height of the range or undefined if the range has no client rectangles.\n */\nexport default function getRangeHeight( range ) {\n\tconst rects = Array.from( range.getClientRects() );\n\n\tif ( ! rects.length ) {\n\t\treturn;\n\t}\n\n\tconst highestTop = Math.min( ...rects.map( ( { top } ) => top ) );\n\tconst lowestBottom = Math.max( ...rects.map( ( { bottom } ) => bottom ) );\n\n\treturn lowestBottom - highestTop;\n}\n","/**\n * Internal dependencies\n */\nimport { assertIsDefined } from '../utils/assert-is-defined';\n\n/**\n * Returns true if the given selection object is in the forward direction, or\n * false otherwise.\n *\n * @see https://developer.mozilla.org/en-US/docs/Web/API/Node/compareDocumentPosition\n *\n * @param {Selection} selection Selection object to check.\n *\n * @return {boolean} Whether the selection is forward.\n */\nexport default function isSelectionForward( selection ) {\n\tconst { anchorNode, focusNode, anchorOffset, focusOffset } = selection;\n\n\tassertIsDefined( anchorNode, 'anchorNode' );\n\tassertIsDefined( focusNode, 'focusNode' );\n\tconst position = anchorNode.compareDocumentPosition( focusNode );\n\n\t// Disable reason: `Node#compareDocumentPosition` returns a bitmask value,\n\t// so bitwise operators are intended.\n\t/* eslint-disable no-bitwise */\n\t// Compare whether anchor node precedes focus node. If focus node (where\n\t// end of selection occurs) is after the anchor node, it is forward.\n\tif ( position & anchorNode.DOCUMENT_POSITION_PRECEDING ) {\n\t\treturn false;\n\t}\n\n\tif ( position & anchorNode.DOCUMENT_POSITION_FOLLOWING ) {\n\t\treturn true;\n\t}\n\t/* eslint-enable no-bitwise */\n\n\t// `compareDocumentPosition` returns 0 when passed the same node, in which\n\t// case compare offsets.\n\tif ( position === 0 ) {\n\t\treturn anchorOffset <= focusOffset;\n\t}\n\n\t// This should never be reached, but return true as default case.\n\treturn true;\n}\n","/**\n * Internal dependencies\n */\nimport caretRangeFromPoint from './caret-range-from-point';\nimport getComputedStyle from './get-computed-style';\n\n/**\n * Get a collapsed range for a given point.\n * Gives the container a temporary high z-index (above any UI).\n * This is preferred over getting the UI nodes and set styles there.\n *\n * @param {Document}    doc       The document of the range.\n * @param {number}      x         Horizontal position within the current viewport.\n * @param {number}      y         Vertical position within the current viewport.\n * @param {HTMLElement} container Container in which the range is expected to be found.\n *\n * @return {?Range} The best range for the given point.\n */\nexport default function hiddenCaretRangeFromPoint( doc, x, y, container ) {\n\tconst originalZIndex = container.style.zIndex;\n\tconst originalPosition = container.style.position;\n\n\tconst { position = 'static' } = getComputedStyle( container );\n\n\t// A z-index only works if the element position is not static.\n\tif ( position === 'static' ) {\n\t\tcontainer.style.position = 'relative';\n\t}\n\n\tcontainer.style.zIndex = '10000';\n\n\tconst range = caretRangeFromPoint( doc, x, y );\n\n\tcontainer.style.zIndex = originalZIndex;\n\tcontainer.style.position = originalPosition;\n\n\treturn range;\n}\n","/**\n * Polyfill.\n * Get a collapsed range for a given point.\n *\n * @see https://developer.mozilla.org/en-US/docs/Web/API/Document/caretRangeFromPoint\n *\n * @param {DocumentMaybeWithCaretPositionFromPoint} doc The document of the range.\n * @param {number}                                  x   Horizontal position within the current viewport.\n * @param {number}                                  y   Vertical position within the current viewport.\n *\n * @return {Range | null} The best range for the given point.\n */\nexport default function caretRangeFromPoint( doc, x, y ) {\n\tif ( doc.caretRangeFromPoint ) {\n\t\treturn doc.caretRangeFromPoint( x, y );\n\t}\n\n\tif ( ! doc.caretPositionFromPoint ) {\n\t\treturn null;\n\t}\n\n\tconst point = doc.caretPositionFromPoint( x, y );\n\n\t// If x or y are negative, outside viewport, or there is no text entry node.\n\t// https://developer.mozilla.org/en-US/docs/Web/API/Document/caretRangeFromPoint\n\tif ( ! point ) {\n\t\treturn null;\n\t}\n\n\tconst range = doc.createRange();\n\n\trange.setStart( point.offsetNode, point.offset );\n\trange.collapse( true );\n\n\treturn range;\n}\n\n/**\n * @typedef {{caretPositionFromPoint?: (x: number, y: number)=> CaretPosition | null} & Document } DocumentMaybeWithCaretPositionFromPoint\n * @typedef {{ readonly offset: number; readonly offsetNode: Node; getClientRect(): DOMRect | null; }} CaretPosition\n */\n","/**\n * Internal dependencies\n */\nimport isRTL from './is-rtl';\nimport getRangeHeight from './get-range-height';\nimport getRectangleFromRange from './get-rectangle-from-range';\nimport isSelectionForward from './is-selection-forward';\nimport hiddenCaretRangeFromPoint from './hidden-caret-range-from-point';\nimport { assertIsDefined } from '../utils/assert-is-defined';\nimport isInputOrTextArea from './is-input-or-text-area';\n\n/**\n * Check whether the selection is at the edge of the container. Checks for\n * horizontal position by default. Set `onlyVertical` to true to check only\n * vertically.\n *\n * @param {Element} container            Focusable element.\n * @param {boolean} isReverse            Set to true to check left, false to check right.\n * @param {boolean} [onlyVertical=false] Set to true to check only vertical position.\n *\n * @return {boolean} True if at the edge, false if not.\n */\nexport default function isEdge( container, isReverse, onlyVertical = false ) {\n\tif (\n\t\tisInputOrTextArea( container ) &&\n\t\ttypeof container.selectionStart === 'number'\n\t) {\n\t\tif ( container.selectionStart !== container.selectionEnd ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif ( isReverse ) {\n\t\t\treturn container.selectionStart === 0;\n\t\t}\n\n\t\treturn container.value.length === container.selectionStart;\n\t}\n\n\tif ( ! (/** @type {HTMLElement} */ ( container ).isContentEditable) ) {\n\t\treturn true;\n\t}\n\n\tconst { ownerDocument } = container;\n\tconst { defaultView } = ownerDocument;\n\n\tassertIsDefined( defaultView, 'defaultView' );\n\tconst selection = defaultView.getSelection();\n\n\tif ( ! selection || ! selection.rangeCount ) {\n\t\treturn false;\n\t}\n\n\tconst range = selection.getRangeAt( 0 );\n\tconst collapsedRange = range.cloneRange();\n\tconst isForward = isSelectionForward( selection );\n\tconst isCollapsed = selection.isCollapsed;\n\n\t// Collapse in direction of selection.\n\tif ( ! isCollapsed ) {\n\t\tcollapsedRange.collapse( ! isForward );\n\t}\n\n\tconst collapsedRangeRect = getRectangleFromRange( collapsedRange );\n\tconst rangeRect = getRectangleFromRange( range );\n\n\tif ( ! collapsedRangeRect || ! rangeRect ) {\n\t\treturn false;\n\t}\n\n\t// Only consider the multiline selection at the edge if the direction is\n\t// towards the edge. The selection is multiline if it is taller than the\n\t// collapsed  selection.\n\tconst rangeHeight = getRangeHeight( range );\n\tif (\n\t\t! isCollapsed &&\n\t\trangeHeight &&\n\t\trangeHeight > collapsedRangeRect.height &&\n\t\tisForward === isReverse\n\t) {\n\t\treturn false;\n\t}\n\n\t// In the case of RTL scripts, the horizontal edge is at the opposite side.\n\tconst isReverseDir = isRTL( container ) ? ! isReverse : isReverse;\n\tconst containerRect = container.getBoundingClientRect();\n\n\t// To check if a selection is at the edge, we insert a test selection at the\n\t// edge of the container and check if the selections have the same vertical\n\t// or horizontal position. If they do, the selection is at the edge.\n\t// This method proves to be better than a DOM-based calculation for the\n\t// horizontal edge, since it ignores empty textnodes and a trailing line\n\t// break element. In other words, we need to check visual positioning, not\n\t// DOM positioning.\n\t// It also proves better than using the computed style for the vertical\n\t// edge, because we cannot know the padding and line height reliably in\n\t// pixels. `getComputedStyle` may return a value with different units.\n\tconst x = isReverseDir ? containerRect.left + 1 : containerRect.right - 1;\n\tconst y = isReverse ? containerRect.top + 1 : containerRect.bottom - 1;\n\tconst testRange = hiddenCaretRangeFromPoint(\n\t\townerDocument,\n\t\tx,\n\t\ty,\n\t\t/** @type {HTMLElement} */ ( container )\n\t);\n\n\tif ( ! testRange ) {\n\t\treturn false;\n\t}\n\n\tconst testRect = getRectangleFromRange( testRange );\n\n\tif ( ! testRect ) {\n\t\treturn false;\n\t}\n\n\tconst verticalSide = isReverse ? 'top' : 'bottom';\n\tconst horizontalSide = isReverseDir ? 'left' : 'right';\n\tconst verticalDiff = testRect[ verticalSide ] - rangeRect[ verticalSide ];\n\tconst horizontalDiff =\n\t\ttestRect[ horizontalSide ] - collapsedRangeRect[ horizontalSide ];\n\n\t// Allow the position to be 1px off.\n\tconst hasVerticalDiff = Math.abs( verticalDiff ) <= 1;\n\tconst hasHorizontalDiff = Math.abs( horizontalDiff ) <= 1;\n\n\treturn onlyVertical\n\t\t? hasVerticalDiff\n\t\t: hasVerticalDiff && hasHorizontalDiff;\n}\n","/**\n * Internal dependencies\n */\nimport isEdge from './is-edge';\n\n/**\n * Check whether the selection is horizontally at the edge of the container.\n *\n * @param {Element} container Focusable element.\n * @param {boolean} isReverse Set to true to check left, false for right.\n *\n * @return {boolean} True if at the horizontal edge, false if not.\n */\nexport default function isHorizontalEdge( container, isReverse ) {\n\treturn isEdge( container, isReverse );\n}\n","/**\n * Internal dependencies\n */\nimport isEdge from './is-edge';\n\n/**\n * Check whether the selection is vertically at the edge of the container.\n *\n * @param {Element} container Focusable element.\n * @param {boolean} isReverse Set to true to check top, false for bottom.\n *\n * @return {boolean} True if at the vertical edge, false if not.\n */\nexport default function isVerticalEdge( container, isReverse ) {\n\treturn isEdge( container, isReverse, true );\n}\n","/**\n * Internal dependencies\n */\nimport hiddenCaretRangeFromPoint from './hidden-caret-range-from-point';\nimport { assertIsDefined } from '../utils/assert-is-defined';\nimport isInputOrTextArea from './is-input-or-text-area';\nimport isRTL from './is-rtl';\n\n/**\n * Gets the range to place.\n *\n * @param {HTMLElement}      container Focusable element.\n * @param {boolean}          isReverse True for end, false for start.\n * @param {number|undefined} x         X coordinate to vertically position.\n *\n * @return {Range|null} The range to place.\n */\nfunction getRange( container, isReverse, x ) {\n\tconst { ownerDocument } = container;\n\t// In the case of RTL scripts, the horizontal edge is at the opposite side.\n\tconst isReverseDir = isRTL( container ) ? ! isReverse : isReverse;\n\tconst containerRect = container.getBoundingClientRect();\n\t// When placing at the end (isReverse), find the closest range to the bottom\n\t// right corner. When placing at the start, to the top left corner.\n\tif ( x === undefined ) {\n\t\tx = isReverse ? containerRect.right - 1 : containerRect.left + 1;\n\t}\n\tconst y = isReverseDir ? containerRect.bottom - 1 : containerRect.top + 1;\n\treturn hiddenCaretRangeFromPoint( ownerDocument, x, y, container );\n}\n\n/**\n * Places the caret at start or end of a given element.\n *\n * @param {HTMLElement}      container Focusable element.\n * @param {boolean}          isReverse True for end, false for start.\n * @param {number|undefined} x         X coordinate to vertically position.\n */\nexport default function placeCaretAtEdge( container, isReverse, x ) {\n\tif ( ! container ) {\n\t\treturn;\n\t}\n\n\tcontainer.focus();\n\n\tif ( isInputOrTextArea( container ) ) {\n\t\t// The element may not support selection setting.\n\t\tif ( typeof container.selectionStart !== 'number' ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( isReverse ) {\n\t\t\tcontainer.selectionStart = container.value.length;\n\t\t\tcontainer.selectionEnd = container.value.length;\n\t\t} else {\n\t\t\tcontainer.selectionStart = 0;\n\t\t\tcontainer.selectionEnd = 0;\n\t\t}\n\n\t\treturn;\n\t}\n\n\tif ( ! container.isContentEditable ) {\n\t\treturn;\n\t}\n\n\tlet range = getRange( container, isReverse, x );\n\n\t// If no range range can be created or it is outside the container, the\n\t// element may be out of view.\n\tif (\n\t\t! range ||\n\t\t! range.startContainer ||\n\t\t! container.contains( range.startContainer )\n\t) {\n\t\tcontainer.scrollIntoView( isReverse );\n\t\trange = range = getRange( container, isReverse, x );\n\n\t\tif (\n\t\t\t! range ||\n\t\t\t! range.startContainer ||\n\t\t\t! container.contains( range.startContainer )\n\t\t) {\n\t\t\treturn;\n\t\t}\n\t}\n\n\tconst { ownerDocument } = container;\n\tconst { defaultView } = ownerDocument;\n\tassertIsDefined( defaultView, 'defaultView' );\n\tconst selection = defaultView.getSelection();\n\tassertIsDefined( selection, 'selection' );\n\tselection.removeAllRanges();\n\tselection.addRange( range );\n}\n","/**\n * Internal dependencies\n */\nimport placeCaretAtEdge from './place-caret-at-edge';\n\n/**\n * Places the caret at start or end of a given element.\n *\n * @param {HTMLElement} container Focusable element.\n * @param {boolean}     isReverse True for end, false for start.\n */\nexport default function placeCaretAtHorizontalEdge( container, isReverse ) {\n\treturn placeCaretAtEdge( container, isReverse, undefined );\n}\n","/**\n * Internal dependencies\n */\nimport placeCaretAtEdge from './place-caret-at-edge';\n\n/**\n * Places the caret at the top or bottom of a given element.\n *\n * @param {HTMLElement} container Focusable element.\n * @param {boolean}     isReverse True for bottom, false for top.\n * @param {DOMRect}     [rect]    The rectangle to position the caret with.\n */\nexport default function placeCaretAtVerticalEdge( container, isReverse, rect ) {\n\treturn placeCaretAtEdge( container, isReverse, rect?.left );\n}\n","/**\n * Internal dependencies\n */\nimport { assertIsDefined } from '../utils/assert-is-defined';\n\n/**\n * Given two DOM nodes, inserts the former in the DOM as the next sibling of\n * the latter.\n *\n * @param {Node} newNode       Node to be inserted.\n * @param {Node} referenceNode Node after which to perform the insertion.\n * @return {void}\n */\nexport default function insertAfter( newNode, referenceNode ) {\n\tassertIsDefined( referenceNode.parentNode, 'referenceNode.parentNode' );\n\treferenceNode.parentNode.insertBefore( newNode, referenceNode.nextSibling );\n}\n","/**\n * Internal dependencies\n */\nimport { assertIsDefined } from '../utils/assert-is-defined';\n\n/**\n * Given a DOM node, removes it from the DOM.\n *\n * @param {Node} node Node to be removed.\n * @return {void}\n */\nexport default function remove( node ) {\n\tassertIsDefined( node.parentNode, 'node.parentNode' );\n\tnode.parentNode.removeChild( node );\n}\n","/**\n * Internal dependencies\n */\nimport { assertIsDefined } from '../utils/assert-is-defined';\nimport insertAfter from './insert-after';\nimport remove from './remove';\n\n/**\n * Given two DOM nodes, replaces the former with the latter in the DOM.\n *\n * @param {Element} processedNode Node to be removed.\n * @param {Element} newNode       Node to be inserted in its place.\n * @return {void}\n */\nexport default function replace( processedNode, newNode ) {\n\tassertIsDefined( processedNode.parentNode, 'processedNode.parentNode' );\n\tinsertAfter( newNode, processedNode.parentNode );\n\tremove( processedNode );\n}\n","/**\n * Internal dependencies\n */\nimport { assertIsDefined } from '../utils/assert-is-defined';\n\n/**\n * Unwrap the given node. This means any child nodes are moved to the parent.\n *\n * @param {Node} node The node to unwrap.\n *\n * @return {void}\n */\nexport default function unwrap( node ) {\n\tconst parent = node.parentNode;\n\n\tassertIsDefined( parent, 'node.parentNode' );\n\n\twhile ( node.firstChild ) {\n\t\tparent.insertBefore( node.firstChild, node );\n\t}\n\n\tparent.removeChild( node );\n}\n","/**\n * Internal dependencies\n */\nimport { assertIsDefined } from '../utils/assert-is-defined';\n\n/**\n * Replaces the given node with a new node with the given tag name.\n *\n * @param {Element} node    The node to replace\n * @param {string}  tagName The new tag name.\n *\n * @return {Element} The new node.\n */\nexport default function replaceTag( node, tagName ) {\n\tconst newNode = node.ownerDocument.createElement( tagName );\n\n\twhile ( node.firstChild ) {\n\t\tnewNode.appendChild( node.firstChild );\n\t}\n\n\tassertIsDefined( node.parentNode, 'node.parentNode' );\n\tnode.parentNode.replaceChild( newNode, node );\n\n\treturn newNode;\n}\n","/**\n * Internal dependencies\n */\nimport { assertIsDefined } from '../utils/assert-is-defined';\n\n/**\n * Wraps the given node with a new node with the given tag name.\n *\n * @param {Element} newNode       The node to insert.\n * @param {Element} referenceNode The node to wrap.\n */\nexport default function wrap( newNode, referenceNode ) {\n\tassertIsDefined( referenceNode.parentNode, 'referenceNode.parentNode' );\n\treferenceNode.parentNode.insertBefore( newNode, referenceNode );\n\tnewNode.appendChild( referenceNode );\n}\n","/**\n * Internal dependencies\n */\nimport remove from './remove';\n\n/**\n * Strips scripts and on* attributes from HTML.\n *\n * @param {string} html HTML to sanitize.\n *\n * @return {string} The sanitized HTML.\n */\nexport default function safeHTML( html ) {\n\tconst { body } = document.implementation.createHTMLDocument( '' );\n\tbody.innerHTML = html;\n\tconst elements = body.getElementsByTagName( '*' );\n\tlet elementIndex = elements.length;\n\n\twhile ( elementIndex-- ) {\n\t\tconst element = elements[ elementIndex ];\n\n\t\tif ( element.tagName === 'SCRIPT' ) {\n\t\t\tremove( element );\n\t\t} else {\n\t\t\tlet attributeIndex = element.attributes.length;\n\n\t\t\twhile ( attributeIndex-- ) {\n\t\t\t\tconst { name: key } = element.attributes[ attributeIndex ];\n\n\t\t\t\tif ( key.startsWith( 'on' ) ) {\n\t\t\t\t\telement.removeAttribute( key );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn body.innerHTML;\n}\n","/**\n * Internal dependencies\n */\nimport safeHTML from './safe-html';\n\n/**\n * Removes any HTML tags from the provided string.\n *\n * @param {string} html The string containing html.\n *\n * @return {string} The text content with any html removed.\n */\nexport default function stripHTML( html ) {\n\t// Remove any script tags or on* attributes otherwise their *contents* will be left\n\t// in place following removal of HTML tags.\n\thtml = safeHTML( html );\n\n\tconst doc = document.implementation.createHTMLDocument( '' );\n\tdoc.body.innerHTML = html;\n\treturn doc.body.textContent || '';\n}\n","/**\n * Recursively checks if an element is empty. An element is not empty if it\n * contains text or contains elements with attributes such as images.\n *\n * @param {Element} element The element to check.\n *\n * @return {boolean} Whether or not the element is empty.\n */\nexport default function isEmpty( element ) {\n\tswitch ( element.nodeType ) {\n\t\tcase element.TEXT_NODE:\n\t\t\t// We cannot use \\s since it includes special spaces which we want\n\t\t\t// to preserve.\n\t\t\treturn /^[ \\f\\n\\r\\t\\v\\u00a0]*$/.test( element.nodeValue || '' );\n\t\tcase element.ELEMENT_NODE:\n\t\t\tif ( element.hasAttributes() ) {\n\t\t\t\treturn false;\n\t\t\t} else if ( ! element.hasChildNodes() ) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\treturn /** @type {Element[]} */ ( Array.from(\n\t\t\t\telement.childNodes\n\t\t\t) ).every( isEmpty );\n\t\tdefault:\n\t\t\treturn true;\n\t}\n}\n","/**\n * External dependencies\n */\nimport { omit, without } from 'lodash';\n\n/**\n * All phrasing content elements.\n *\n * @see https://www.w3.org/TR/2011/WD-html5-20110525/content-models.html#phrasing-content-0\n */\n\n/**\n * @typedef {Record<string,SemanticElementDefinition>} ContentSchema\n */\n\n/**\n * @typedef SemanticElementDefinition\n * @property {string[]}      [attributes] Content attributes\n * @property {ContentSchema} [children]   Content attributes\n */\n\n/**\n * All text-level semantic elements.\n *\n * @see https://html.spec.whatwg.org/multipage/text-level-semantics.html\n *\n * @type {ContentSchema}\n */\nconst textContentSchema = {\n\tstrong: {},\n\tem: {},\n\ts: {},\n\tdel: {},\n\tins: {},\n\ta: { attributes: [ 'href', 'target', 'rel', 'id' ] },\n\tcode: {},\n\tabbr: { attributes: [ 'title' ] },\n\tsub: {},\n\tsup: {},\n\tbr: {},\n\tsmall: {},\n\t// To do: fix blockquote.\n\t// cite: {},\n\tq: { attributes: [ 'cite' ] },\n\tdfn: { attributes: [ 'title' ] },\n\tdata: { attributes: [ 'value' ] },\n\ttime: { attributes: [ 'datetime' ] },\n\tvar: {},\n\tsamp: {},\n\tkbd: {},\n\ti: {},\n\tb: {},\n\tu: {},\n\tmark: {},\n\truby: {},\n\trt: {},\n\trp: {},\n\tbdi: { attributes: [ 'dir' ] },\n\tbdo: { attributes: [ 'dir' ] },\n\twbr: {},\n\t'#text': {},\n};\n\n// Recursion is needed.\n// Possible: strong > em > strong.\n// Impossible: strong > strong.\nwithout( Object.keys( textContentSchema ), '#text', 'br' ).forEach( ( tag ) => {\n\ttextContentSchema[ tag ].children = omit( textContentSchema, tag );\n} );\n\n/**\n * Embedded content elements.\n *\n * @see https://www.w3.org/TR/2011/WD-html5-20110525/content-models.html#embedded-content-0\n *\n * @type {ContentSchema}\n */\nconst embeddedContentSchema = {\n\taudio: {\n\t\tattributes: [\n\t\t\t'src',\n\t\t\t'preload',\n\t\t\t'autoplay',\n\t\t\t'mediagroup',\n\t\t\t'loop',\n\t\t\t'muted',\n\t\t],\n\t},\n\tcanvas: { attributes: [ 'width', 'height' ] },\n\tembed: { attributes: [ 'src', 'type', 'width', 'height' ] },\n\timg: {\n\t\tattributes: [\n\t\t\t'alt',\n\t\t\t'src',\n\t\t\t'srcset',\n\t\t\t'usemap',\n\t\t\t'ismap',\n\t\t\t'width',\n\t\t\t'height',\n\t\t],\n\t},\n\tobject: {\n\t\tattributes: [\n\t\t\t'data',\n\t\t\t'type',\n\t\t\t'name',\n\t\t\t'usemap',\n\t\t\t'form',\n\t\t\t'width',\n\t\t\t'height',\n\t\t],\n\t},\n\tvideo: {\n\t\tattributes: [\n\t\t\t'src',\n\t\t\t'poster',\n\t\t\t'preload',\n\t\t\t'autoplay',\n\t\t\t'mediagroup',\n\t\t\t'loop',\n\t\t\t'muted',\n\t\t\t'controls',\n\t\t\t'width',\n\t\t\t'height',\n\t\t],\n\t},\n};\n\n/**\n * Phrasing content elements.\n *\n * @see https://www.w3.org/TR/2011/WD-html5-20110525/content-models.html#phrasing-content-0\n */\nconst phrasingContentSchema = {\n\t...textContentSchema,\n\t...embeddedContentSchema,\n};\n\n/**\n * Get schema of possible paths for phrasing content.\n *\n * @see https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/Content_categories#Phrasing_content\n *\n * @param {string} [context] Set to \"paste\" to exclude invisible elements and\n *                           sensitive data.\n *\n * @return {Partial<ContentSchema>} Schema.\n */\nexport function getPhrasingContentSchema( context ) {\n\tif ( context !== 'paste' ) {\n\t\treturn phrasingContentSchema;\n\t}\n\n\treturn omit(\n\t\t{\n\t\t\t...phrasingContentSchema,\n\t\t\t// We shouldn't paste potentially sensitive information which is not\n\t\t\t// visible to the user when pasted, so strip the attributes.\n\t\t\tins: { children: phrasingContentSchema.ins.children },\n\t\t\tdel: { children: phrasingContentSchema.del.children },\n\t\t},\n\t\t[\n\t\t\t'u', // Used to mark misspelling. Shouldn't be pasted.\n\t\t\t'abbr', // Invisible.\n\t\t\t'data', // Invisible.\n\t\t\t'time', // Invisible.\n\t\t\t'wbr', // Invisible.\n\t\t\t'bdi', // Invisible.\n\t\t\t'bdo', // Invisible.\n\t\t]\n\t);\n}\n\n/**\n * Find out whether or not the given node is phrasing content.\n *\n * @see https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/Content_categories#Phrasing_content\n *\n * @param {Node} node The node to test.\n *\n * @return {boolean} True if phrasing content, false if not.\n */\nexport function isPhrasingContent( node ) {\n\tconst tag = node.nodeName.toLowerCase();\n\treturn getPhrasingContentSchema().hasOwnProperty( tag ) || tag === 'span';\n}\n\n/**\n * @param {Node} node\n * @return {boolean} Node is text content\n */\nexport function isTextContent( node ) {\n\tconst tag = node.nodeName.toLowerCase();\n\treturn textContentSchema.hasOwnProperty( tag ) || tag === 'span';\n}\n","/**\n * External dependencies\n */\nimport { includes, noop } from 'lodash';\n\n/**\n * Internal dependencies\n */\nimport isEmpty from './is-empty';\nimport remove from './remove';\nimport unwrap from './unwrap';\nimport { isPhrasingContent } from '../phrasing-content';\nimport insertAfter from './insert-after';\nimport isElement from './is-element';\n\n/* eslint-disable jsdoc/valid-types */\n/**\n * @typedef SchemaItem\n * @property {string[]}                            [attributes] Attributes.\n * @property {(string | RegExp)[]}                 [classes]    Classnames or RegExp to test against.\n * @property {'*' | { [tag: string]: SchemaItem }} [children]   Child schemas.\n * @property {string[]}                            [require]    Selectors to test required children against. Leave empty or undefined if there are no requirements.\n * @property {boolean}                             allowEmpty   Whether to allow nodes without children.\n * @property {(node: Node) => boolean}             [isMatch]    Function to test whether a node is a match. If left undefined any node will be assumed to match.\n */\n\n/** @typedef {{ [tag: string]: SchemaItem }} Schema */\n/* eslint-enable jsdoc/valid-types */\n\n/**\n * Given a schema, unwraps or removes nodes, attributes and classes on a node\n * list.\n *\n * @param {NodeList} nodeList The nodeList to filter.\n * @param {Document} doc      The document of the nodeList.\n * @param {Schema}   schema   An array of functions that can mutate with the provided node.\n * @param {boolean}  inline   Whether to clean for inline mode.\n */\nexport default function cleanNodeList( nodeList, doc, schema, inline ) {\n\tArray.from( nodeList ).forEach( (\n\t\t/** @type {Node & { nextElementSibling?: unknown }} */ node\n\t) => {\n\t\tconst tag = node.nodeName.toLowerCase();\n\n\t\t// It's a valid child, if the tag exists in the schema without an isMatch\n\t\t// function, or with an isMatch function that matches the node.\n\t\tif (\n\t\t\tschema.hasOwnProperty( tag ) &&\n\t\t\t( ! schema[ tag ].isMatch || schema[ tag ].isMatch?.( node ) )\n\t\t) {\n\t\t\tif ( isElement( node ) ) {\n\t\t\t\tconst {\n\t\t\t\t\tattributes = [],\n\t\t\t\t\tclasses = [],\n\t\t\t\t\tchildren,\n\t\t\t\t\trequire = [],\n\t\t\t\t\tallowEmpty,\n\t\t\t\t} = schema[ tag ];\n\n\t\t\t\t// If the node is empty and it's supposed to have children,\n\t\t\t\t// remove the node.\n\t\t\t\tif ( children && ! allowEmpty && isEmpty( node ) ) {\n\t\t\t\t\tremove( node );\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif ( node.hasAttributes() ) {\n\t\t\t\t\t// Strip invalid attributes.\n\t\t\t\t\tArray.from( node.attributes ).forEach( ( { name } ) => {\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\tname !== 'class' &&\n\t\t\t\t\t\t\t! includes( attributes, name )\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tnode.removeAttribute( name );\n\t\t\t\t\t\t}\n\t\t\t\t\t} );\n\n\t\t\t\t\t// Strip invalid classes.\n\t\t\t\t\t// In jsdom-jscore, 'node.classList' can be undefined.\n\t\t\t\t\t// TODO: Explore patching this in jsdom-jscore.\n\t\t\t\t\tif ( node.classList && node.classList.length ) {\n\t\t\t\t\t\tconst mattchers = classes.map( ( item ) => {\n\t\t\t\t\t\t\tif ( typeof item === 'string' ) {\n\t\t\t\t\t\t\t\treturn ( /** @type {string} */ className ) =>\n\t\t\t\t\t\t\t\t\tclassName === item;\n\t\t\t\t\t\t\t} else if ( item instanceof RegExp ) {\n\t\t\t\t\t\t\t\treturn ( /** @type {string} */ className ) =>\n\t\t\t\t\t\t\t\t\titem.test( className );\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\treturn noop;\n\t\t\t\t\t\t} );\n\n\t\t\t\t\t\tArray.from( node.classList ).forEach( ( name ) => {\n\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t! mattchers.some( ( isMatch ) =>\n\t\t\t\t\t\t\t\t\tisMatch( name )\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\tnode.classList.remove( name );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} );\n\n\t\t\t\t\t\tif ( ! node.classList.length ) {\n\t\t\t\t\t\t\tnode.removeAttribute( 'class' );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif ( node.hasChildNodes() ) {\n\t\t\t\t\t// Do not filter any content.\n\t\t\t\t\tif ( children === '*' ) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Continue if the node is supposed to have children.\n\t\t\t\t\tif ( children ) {\n\t\t\t\t\t\t// If a parent requires certain children, but it does\n\t\t\t\t\t\t// not have them, drop the parent and continue.\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\trequire.length &&\n\t\t\t\t\t\t\t! node.querySelector( require.join( ',' ) )\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tcleanNodeList(\n\t\t\t\t\t\t\t\tnode.childNodes,\n\t\t\t\t\t\t\t\tdoc,\n\t\t\t\t\t\t\t\tschema,\n\t\t\t\t\t\t\t\tinline\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tunwrap( node );\n\t\t\t\t\t\t\t// If the node is at the top, phrasing content, and\n\t\t\t\t\t\t\t// contains children that are block content, unwrap\n\t\t\t\t\t\t\t// the node because it is invalid.\n\t\t\t\t\t\t} else if (\n\t\t\t\t\t\t\tnode.parentNode &&\n\t\t\t\t\t\t\tnode.parentNode.nodeName === 'BODY' &&\n\t\t\t\t\t\t\tisPhrasingContent( node )\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tcleanNodeList(\n\t\t\t\t\t\t\t\tnode.childNodes,\n\t\t\t\t\t\t\t\tdoc,\n\t\t\t\t\t\t\t\tschema,\n\t\t\t\t\t\t\t\tinline\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\tArray.from( node.childNodes ).some(\n\t\t\t\t\t\t\t\t\t( child ) => ! isPhrasingContent( child )\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\tunwrap( node );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tcleanNodeList(\n\t\t\t\t\t\t\t\tnode.childNodes,\n\t\t\t\t\t\t\t\tdoc,\n\t\t\t\t\t\t\t\tchildren,\n\t\t\t\t\t\t\t\tinline\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// Remove children if the node is not supposed to have any.\n\t\t\t\t\t} else {\n\t\t\t\t\t\twhile ( node.firstChild ) {\n\t\t\t\t\t\t\tremove( node.firstChild );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Invalid child. Continue with schema at the same place and unwrap.\n\t\t} else {\n\t\t\tcleanNodeList( node.childNodes, doc, schema, inline );\n\n\t\t\t// For inline mode, insert a line break when unwrapping nodes that\n\t\t\t// are not phrasing content.\n\t\t\tif (\n\t\t\t\tinline &&\n\t\t\t\t! isPhrasingContent( node ) &&\n\t\t\t\tnode.nextElementSibling\n\t\t\t) {\n\t\t\t\tinsertAfter( doc.createElement( 'br' ), node );\n\t\t\t}\n\n\t\t\tunwrap( node );\n\t\t}\n\t} );\n}\n","/* eslint-disable jsdoc/valid-types */\n/**\n * @param {Node | null | undefined} node\n * @return {node is Element} True if node is an Element node\n */\nexport default function isElement( node ) {\n\t/* eslint-enable jsdoc/valid-types */\n\treturn !! node && node.nodeType === node.ELEMENT_NODE;\n}\n","/**\n * Internal dependencies\n */\nimport cleanNodeList from './clean-node-list';\n\n/**\n * Given a schema, unwraps or removes nodes, attributes and classes on HTML.\n *\n * @param {string}                             HTML   The HTML to clean up.\n * @param {import('./clean-node-list').Schema} schema Schema for the HTML.\n * @param {boolean}                            inline Whether to clean for inline mode.\n *\n * @return {string} The cleaned up HTML.\n */\nexport default function removeInvalidHTML( HTML, schema, inline ) {\n\tconst doc = document.implementation.createHTMLDocument( '' );\n\n\tdoc.body.innerHTML = HTML;\n\n\tcleanNodeList( doc.body.childNodes, doc, schema, inline );\n\n\treturn doc.body.innerHTML;\n}\n","/**\n * Gets all files from a DataTransfer object.\n *\n * @param {DataTransfer} dataTransfer DataTransfer object to inspect.\n *\n * @return {File[]} An array containing all files.\n */\nexport function getFilesFromDataTransfer( dataTransfer ) {\n\tconst files = Array.from( dataTransfer.files );\n\n\tArray.from( dataTransfer.items ).forEach( ( item ) => {\n\t\tconst file = item.getAsFile();\n\n\t\tif (\n\t\t\tfile &&\n\t\t\t! files.find(\n\t\t\t\t( { name, type, size } ) =>\n\t\t\t\t\tname === file.name &&\n\t\t\t\t\ttype === file.type &&\n\t\t\t\t\tsize === file.size\n\t\t\t)\n\t\t) {\n\t\t\tfiles.push( file );\n\t\t}\n\t} );\n\n\treturn files;\n}\n","/**\n * Internal dependencies\n */\nimport * as focusable from './focusable';\nimport * as tabbable from './tabbable';\n\n/**\n * Object grouping `focusable` and `tabbable` utils\n * under the keys with the same name.\n */\nexport const focus = { focusable, tabbable };\n\nexport * from './dom';\nexport * from './phrasing-content';\nexport * from './data-transfer';\n"],"names":["__webpack_require__","exports","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","Symbol","toStringTag","value","buildSelector","sequential","join","isVisible","element","offsetWidth","offsetHeight","getClientRects","length","isValidFocusableArea","map","closest","img","ownerDocument","querySelector","name","find","context","elements","querySelectorAll","Array","from","filter","nodeName","window","getTabIndex","tabIndex","getAttribute","parseInt","isTabbableIndex","mapElementToObjectTabbable","index","mapObjectTabbableToElement","object","compareObjectTabbables","a","b","aTabIndex","bTabIndex","filterTabbable","focusables","sort","reduce","CHOSEN_RADIO_BY_NAME","result","type","checked","concat","hasChosen","hadChosenElement","without","createStatefulCollapseRadioGroup","findFocusable","findPrevious","body","indexOf","last","findNext","remaining","slice","first","getRectangleFromRange","range","collapsed","rects","filteredRects","width","getBoundingClientRect","top","furthestTop","bottom","furthestBottom","left","furthestLeft","right","furthestRight","DOMRect","startContainer","parentNode","childNodes","createRange","setStart","setEnd","rect","padNode","createTextNode","cloneRange","insertNode","removeChild","computeCaretRect","win","selection","getSelection","rangeCount","getRangeAt","documentHasTextSelection","doc","defaultView","isHTMLInputElement","node","isTextField","includes","contentEditable","isNumberInput","valueAsNumber","documentHasUncollapsedSelection","activeElement","selectionStart","selectionEnd","error","inputFieldHasUncollapsedSelection","documentHasSelection","getComputedStyle","getScrollContainer","scrollHeight","clientHeight","overflowY","test","getOffsetParent","closestElement","nodeType","ELEMENT_NODE","position","isInputOrTextArea","tagName","isEntirelySelected","isContentEditable","endContainer","startOffset","endOffset","lastChild","endContainerContentLength","TEXT_NODE","data","isDeepChild","query","container","propName","candidate","isRTL","direction","getRangeHeight","highestTop","Math","min","max","isSelectionForward","anchorNode","focusNode","anchorOffset","focusOffset","compareDocumentPosition","DOCUMENT_POSITION_PRECEDING","DOCUMENT_POSITION_FOLLOWING","hiddenCaretRangeFromPoint","x","y","originalZIndex","style","zIndex","originalPosition","caretRangeFromPoint","caretPositionFromPoint","point","offsetNode","offset","collapse","isEdge","isReverse","onlyVertical","collapsedRange","isForward","isCollapsed","collapsedRangeRect","rangeRect","rangeHeight","height","isReverseDir","containerRect","testRange","testRect","verticalSide","horizontalSide","verticalDiff","horizontalDiff","hasVerticalDiff","abs","hasHorizontalDiff","isHorizontalEdge","isVerticalEdge","getRange","undefined","placeCaretAtEdge","focus","contains","scrollIntoView","removeAllRanges","addRange","placeCaretAtHorizontalEdge","placeCaretAtVerticalEdge","insertAfter","newNode","referenceNode","insertBefore","nextSibling","remove","replace","processedNode","unwrap","parent","firstChild","replaceTag","createElement","appendChild","replaceChild","wrap","safeHTML","html","document","implementation","createHTMLDocument","innerHTML","getElementsByTagName","elementIndex","attributeIndex","attributes","startsWith","removeAttribute","stripHTML","textContent","isEmpty","nodeValue","hasAttributes","hasChildNodes","every","textContentSchema","strong","em","s","del","ins","code","abbr","sub","sup","br","small","q","dfn","time","var","samp","kbd","i","u","mark","ruby","rt","rp","bdi","bdo","wbr","keys","forEach","tag","children","omit","phrasingContentSchema","audio","canvas","embed","video","getPhrasingContentSchema","isPhrasingContent","toLowerCase","isTextContent","cleanNodeList","nodeList","schema","inline","isMatch","isElement","classes","require","allowEmpty","classList","mattchers","item","className","RegExp","noop","some","child","nextElementSibling","removeInvalidHTML","HTML","getFilesFromDataTransfer","dataTransfer","files","items","file","getAsFile","size","push","focusable","tabbable"],"sourceRoot":""}